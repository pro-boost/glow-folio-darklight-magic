{"version":3,"file":"app-hooks-wIPcnTOB.js","sources":["../../../src/hooks/use-toast.ts","../../../src/hooks/use-scroll-spy.tsx","../../../src/hooks/use-mobile.tsx"],"sourcesContent":["import * as React from \"react\"\r\n\r\nimport type {\r\n  ToastActionElement,\r\n  ToastProps,\r\n} from \"@/components/ui/toast\"\r\n\r\nconst TOAST_LIMIT = 1\r\nconst TOAST_REMOVE_DELAY = 1000000\r\n\r\ntype ToasterToast = ToastProps & {\r\n  id: string\r\n  title?: React.ReactNode\r\n  description?: React.ReactNode\r\n  action?: ToastActionElement\r\n}\r\n\r\nconst actionTypes = {\r\n  ADD_TOAST: \"ADD_TOAST\",\r\n  UPDATE_TOAST: \"UPDATE_TOAST\",\r\n  DISMISS_TOAST: \"DISMISS_TOAST\",\r\n  REMOVE_TOAST: \"REMOVE_TOAST\",\r\n} as const\r\n\r\nlet count = 0\r\n\r\nfunction genId() {\r\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\r\n  return count.toString()\r\n}\r\n\r\ntype ActionType = typeof actionTypes\r\n\r\ntype Action =\r\n  | {\r\n      type: ActionType[\"ADD_TOAST\"]\r\n      toast: ToasterToast\r\n    }\r\n  | {\r\n      type: ActionType[\"UPDATE_TOAST\"]\r\n      toast: Partial<ToasterToast>\r\n    }\r\n  | {\r\n      type: ActionType[\"DISMISS_TOAST\"]\r\n      toastId?: ToasterToast[\"id\"]\r\n    }\r\n  | {\r\n      type: ActionType[\"REMOVE_TOAST\"]\r\n      toastId?: ToasterToast[\"id\"]\r\n    }\r\n\r\ninterface State {\r\n  toasts: ToasterToast[]\r\n}\r\n\r\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\r\n\r\nconst addToRemoveQueue = (toastId: string) => {\r\n  if (toastTimeouts.has(toastId)) {\r\n    return\r\n  }\r\n\r\n  const timeout = setTimeout(() => {\r\n    toastTimeouts.delete(toastId)\r\n    dispatch({\r\n      type: \"REMOVE_TOAST\",\r\n      toastId: toastId,\r\n    })\r\n  }, TOAST_REMOVE_DELAY)\r\n\r\n  toastTimeouts.set(toastId, timeout)\r\n}\r\n\r\nexport const reducer = (state: State, action: Action): State => {\r\n  switch (action.type) {\r\n    case \"ADD_TOAST\":\r\n      return {\r\n        ...state,\r\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\r\n      }\r\n\r\n    case \"UPDATE_TOAST\":\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.map((t) =>\r\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\r\n        ),\r\n      }\r\n\r\n    case \"DISMISS_TOAST\": {\r\n      const { toastId } = action\r\n\r\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\r\n      // but I'll keep it here for simplicity\r\n      if (toastId) {\r\n        addToRemoveQueue(toastId)\r\n      } else {\r\n        state.toasts.forEach((toast) => {\r\n          addToRemoveQueue(toast.id)\r\n        })\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.map((t) =>\r\n          t.id === toastId || toastId === undefined\r\n            ? {\r\n                ...t,\r\n                open: false,\r\n              }\r\n            : t\r\n        ),\r\n      }\r\n    }\r\n    case \"REMOVE_TOAST\":\r\n      if (action.toastId === undefined) {\r\n        return {\r\n          ...state,\r\n          toasts: [],\r\n        }\r\n      }\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\r\n      }\r\n  }\r\n}\r\n\r\nconst listeners: Array<(state: State) => void> = []\r\n\r\nlet memoryState: State = { toasts: [] }\r\n\r\nfunction dispatch(action: Action) {\r\n  memoryState = reducer(memoryState, action)\r\n  listeners.forEach((listener) => {\r\n    listener(memoryState)\r\n  })\r\n}\r\n\r\ntype Toast = Omit<ToasterToast, \"id\">\r\n\r\nfunction toast({ ...props }: Toast) {\r\n  const id = genId()\r\n\r\n  const update = (props: ToasterToast) =>\r\n    dispatch({\r\n      type: \"UPDATE_TOAST\",\r\n      toast: { ...props, id },\r\n    })\r\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\r\n\r\n  dispatch({\r\n    type: \"ADD_TOAST\",\r\n    toast: {\r\n      ...props,\r\n      id,\r\n      open: true,\r\n      onOpenChange: (open) => {\r\n        if (!open) dismiss()\r\n      },\r\n    },\r\n  })\r\n\r\n  return {\r\n    id: id,\r\n    dismiss,\r\n    update,\r\n  }\r\n}\r\n\r\nfunction useToast() {\r\n  const [state, setState] = React.useState<State>(memoryState)\r\n\r\n  React.useEffect(() => {\r\n    listeners.push(setState)\r\n    return () => {\r\n      const index = listeners.indexOf(setState)\r\n      if (index > -1) {\r\n        listeners.splice(index, 1)\r\n      }\r\n    }\r\n  }, [state])\r\n\r\n  return {\r\n    ...state,\r\n    toast,\r\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\r\n  }\r\n}\r\n\r\nexport { useToast, toast }\r\n","import { useState, useEffect } from \"react\";\r\n\r\n// Custom hook for scroll spying and detecting which section is in view\r\nexport default function useScrollSpy(sectionIds: string[]) {\r\n  const [activeSection, setActiveSection] = useState<string>(\"\");\r\n\r\n  useEffect(() => {\r\n    const handleScroll = () => {\r\n      const sections = sectionIds.map((id) => document.getElementById(id));\r\n\r\n      // Check each section to see if it's in the viewport\r\n      let currentSection = \"\";\r\n      sections.forEach((section) => {\r\n        if (section && isElementInViewport(section)) {\r\n          currentSection = section.id;\r\n        }\r\n      });\r\n\r\n      // Update active section\r\n      if (currentSection) {\r\n        setActiveSection(currentSection);\r\n      }\r\n    };\r\n\r\n    const isElementInViewport = (el: HTMLElement) => {\r\n      const rect = el.getBoundingClientRect();\r\n      return rect.top <= 0 && rect.bottom >= 0;\r\n    };\r\n\r\n    // Attach the scroll event listener\r\n    window.addEventListener(\"scroll\", handleScroll);\r\n    handleScroll(); // Run once on initial load\r\n\r\n    return () => window.removeEventListener(\"scroll\", handleScroll);\r\n  }, [sectionIds]);\r\n\r\n  return activeSection;\r\n}\r\n","import * as React from \"react\"\r\n\r\nconst MOBILE_BREAKPOINT = 768\r\n\r\nexport function useIsMobile() {\r\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\r\n\r\n  React.useEffect(() => {\r\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\r\n    const onChange = () => {\r\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\r\n    }\r\n    mql.addEventListener(\"change\", onChange)\r\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\r\n    return () => mql.removeEventListener(\"change\", onChange)\r\n  }, [])\r\n\r\n  return !!isMobile\r\n}\r\n"],"names":["count","toastTimeouts","Map","addToRemoveQueue","toastId","has","timeout","setTimeout","delete","dispatch","type","set","reducer","state","action","toasts","toast","slice","map","t","id","forEach","open","filter","listeners","memoryState","listener","props","Number","MAX_SAFE_INTEGER","toString","dismiss","onOpenChange","update","useToast","setState","React.useState","React.useEffect","push","index","indexOf","splice","useScrollSpy","sectionIds","activeSection","setActiveSection","useState","useEffect","handleScroll","sections","document","getElementById","currentSection","section","isElementInViewport","el","rect","getBoundingClientRect","top","bottom","window","addEventListener","removeEventListener","useIsMobile","isMobile","setIsMobile","mql","matchMedia","onChange","innerWidth"],"mappings":"+CAwBA,IAAIA,EAAQ,EA+BZ,MAAMC,MAAoBC,IAEpBC,EAAoBC,IACpB,GAAAH,EAAcI,IAAID,GACpB,OAGI,MAAAE,EAAUC,YAAW,KACzBN,EAAcO,OAAOJ,GACZK,EAAA,CACPC,KAAM,eACNN,cA1DqB,KA8DXH,EAAAU,IAAIP,EAASE,IAGhBM,EAAU,CAACC,EAAcC,KACpC,OAAQA,EAAOJ,MACb,IAAK,YACI,MAAA,IACFG,EACHE,OAAQ,CAACD,EAAOE,SAAUH,EAAME,QAAQE,MAAM,EAvElC,IA0EhB,IAAK,eACI,MAAA,IACFJ,EACHE,OAAQF,EAAME,OAAOG,KAAKC,GACxBA,EAAEC,KAAON,EAAOE,MAAMI,GAAK,IAAKD,KAAML,EAAOE,OAAUG,KAI7D,IAAK,gBAAiB,CACd,MAAAf,QAAEA,GAAYU,EAYb,OARHV,EACFD,EAAiBC,GAEXS,EAAAE,OAAOM,SAASL,IACpBb,EAAiBa,EAAMI,OAIpB,IACFP,EACHE,OAAQF,EAAME,OAAOG,KAAKC,GACxBA,EAAEC,KAAOhB,QAAuB,IAAZA,EAChB,IACKe,EACHG,MAAM,GAERH,IAGV,CACA,IAAK,eACC,YAAmB,IAAnBL,EAAOV,QACF,IACFS,EACHE,OAAQ,IAGL,IACFF,EACHE,OAAQF,EAAME,OAAOQ,QAAQJ,GAAMA,EAAEC,KAAON,EAAOV,aAKrDoB,EAA2C,GAEjD,IAAIC,EAAqB,CAAEV,OAAQ,IAEnC,SAASN,EAASK,GACFW,EAAAb,EAAQa,EAAaX,GACzBU,EAAAH,SAASK,IACjBA,EAASD,KAEb,CAIA,SAAST,MAAWW,IAClB,MAAMP,GAnHGpB,GAAAA,EAAQ,GAAK4B,OAAOC,iBACtB7B,EAAM8B,YAyHPC,EAAU,IAAMtB,EAAS,CAAEC,KAAM,gBAAiBN,QAASgB,IAc1D,OAZEX,EAAA,CACPC,KAAM,YACNM,MAAO,IACFW,EACHP,KACAE,MAAM,EACNU,aAAeV,IACRA,WAKJ,CACLF,KACAW,UACAE,OAtBcN,GACdlB,EAAS,CACPC,KAAM,eACNM,MAAO,IAAKW,EAAOP,QAqBzB,CAEA,SAASc,IACP,MAAOrB,EAAOsB,GAAYC,WAAsBX,GAYzC,OAVPY,EAAAA,WAAgB,KACdb,EAAUc,KAAKH,GACR,KACC,MAAAI,EAAQf,EAAUgB,QAAQL,GAC5BI,GAAY,GACJf,EAAAiB,OAAOF,EAAO,MAG3B,CAAC1B,IAEG,IACFA,EACHG,QACAe,QAAU3B,GAAqBK,EAAS,CAAEC,KAAM,gBAAiBN,YAErE,CCzLA,SAAwBsC,EAAaC,GACnC,MAAOC,EAAeC,GAAoBC,WAAiB,IAgCpD,OA9BPC,EAAAA,WAAU,KACR,MAAMC,EAAe,KACb,MAAAC,EAAWN,EAAWzB,KAAKE,GAAO8B,SAASC,eAAe/B,KAGhE,IAAIgC,EAAiB,GACZH,EAAA5B,SAASgC,IACZA,GAAWC,EAAoBD,KACjCD,EAAiBC,EAAQjC,OAKzBgC,GACFP,EAAiBO,IAIfE,EAAuBC,IACrB,MAAAC,EAAOD,EAAGE,wBAChB,OAAOD,EAAKE,KAAO,GAAKF,EAAKG,QAAU,GAOzC,OAHOC,OAAAC,iBAAiB,SAAUb,OAG3B,IAAMY,OAAOE,oBAAoB,SAAUd,KACjD,CAACL,IAEGC,CACT,CCjCO,SAASmB,IACd,MAAOC,EAAUC,GAAe7B,EAAAA,cAAoC,GAYpE,OAVAC,EAAAA,WAAgB,KACd,MAAM6B,EAAMN,OAAOO,WAAW,sBACxBC,EAAW,KACHH,EAAAL,OAAOS,WARC,MAYtB,OAFIH,EAAAL,iBAAiB,SAAUO,GACnBH,EAAAL,OAAOS,WAXG,KAYf,IAAMH,EAAIJ,oBAAoB,SAAUM,KAC9C,MAEMJ,CACX"}